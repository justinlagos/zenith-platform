<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZENITH: Clinical Resonance v3.4.5 (Email Active)</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* --- DYNAMIC THEME SYSTEM --- */
        :root {
            --bg-base: #050505;
            --bg-panel: #0F0F0F;
            --border: rgba(255, 255, 255, 0.12);
            --text-pri: #F0F2F5;
            --text-sec: #888899;
            --accent: #00A3FF; 
            --success: #34C759;
            --alert: #FF3B30;
            --warning: #FF9500;
            --radius: 4px;
            
            /* 8pt Grid System - Spacing Variables */
            --spacing-xs: 8px;
            --spacing-sm: 16px;
            --spacing-md: 24px;
            --spacing-lg: 32px;
            --spacing-xl: 40px;
        }

        [data-theme="light"] {
            --bg-base: #F5F7FA;
            --bg-panel: #FFFFFF;
            --border: rgba(0, 0, 0, 0.1);
            --text-pri: #1A1A1A;
            --text-sec: #555566;
            --accent: #0066CC;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            background-color: var(--bg-base); color: var(--text-pri);
            font-family: 'Inter', sans-serif;
            overflow: hidden; height: 100vh; width: 100vw;
            transition: background-color 0.4s ease, color 0.4s ease;
        }

        /* TYPOGRAPHY SYSTEM - SWISS MEDICAL GRADE */
        /* Inter: UI text (300, 400, 500, 600) | JetBrains Mono: Data/metrics (400, 500, 700) */
        .t-hero { font-size: 48px; letter-spacing: -0.02em; font-weight: 600; line-height: 1.1; }
        .t-h2 { font-size: 24px; font-weight: 500; letter-spacing: -0.02em; }
        .t-h3 { font-size: 16px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; }
        .t-mono { font-family: 'JetBrains Mono', monospace; font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em; }
        .t-body { font-size: 15px; line-height: 1.6; color: var(--text-sec); }
        .t-muted { color: var(--text-sec); }
        .t-accent { color: var(--accent); }

        /* VIEW MANAGEMENT */
        .view { 
            position: absolute; inset: 0; 
            display: none; 
            padding: 32px; overflow-y: auto; 
            opacity: 0; transition: opacity 0.5s ease; 
            z-index: 5; 
        }
        .view.active { display: block; opacity: 1; }
        
        .container { max-width: 1100px; margin: 0 auto; min-height: 100%; display: flex; flex-direction: column; }
        .center-col { align-items: center; justify-content: center; text-align: center; }
        
        /* UI ELEMENTS */
        .theme-toggle {
            position: absolute; top: var(--spacing-lg); right: var(--spacing-lg); z-index: 50;
            width: 40px; height: 40px; border-radius: 50%;
            border: 1px solid var(--border); background: var(--bg-panel);
            color: var(--text-pri); display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .theme-toggle:hover { border-color: var(--accent); color: var(--accent); }

        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: var(--spacing-md); width: 100%; padding-bottom: var(--spacing-xl); }
        
        .card {
            border: 1px solid var(--border); background: var(--bg-panel);
            padding: var(--spacing-md); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); cursor: pointer; border-radius: var(--radius);
            display: flex; flex-direction: column; justify-content: space-between;
            min-height: 220px; user-select: none;
        }
        .card:hover { border-color: var(--accent); transform: translateY(-2px); }
        .card:active { transform: scale(0.98); background: var(--accent); color: white; }
        .card:active p, .card:active .t-muted { color: rgba(255,255,255,0.8); }

        .btn {
            background: var(--text-pri); color: var(--bg-base);
            padding: 14px 28px; border: 1px solid var(--text-pri);
            font-family: 'JetBrains Mono', monospace; font-size: 12px;
            cursor: pointer; transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); text-transform: uppercase; font-weight: 700;
            border-radius: var(--radius); display: inline-flex; align-items: center; gap: 10px;
        }
        .btn:hover { opacity: 0.8; }
        .btn-ghost { background: transparent; color: var(--text-pri); border: 1px solid var(--border); }
        .btn-ghost:hover { border-color: var(--accent); color: var(--accent); }

        input {
            background: transparent; border: none; border-bottom: 1px solid var(--border);
            color: var(--text-pri); font-size: 18px; padding: 12px 0; width: 100%;
            font-family: 'Inter', sans-serif; outline: none; margin-bottom: 24px;
        }
        input:focus { border-color: var(--accent); }

        /* VISUALIZER */
        #canvas-layer { position: fixed; inset: 0; z-index: 1; opacity: 0; transition: opacity 1s; }
        #canvas-layer.active { opacity: 1; }
        video { display: none; }

        /* HUD & DASHBOARD */
        #hud-layer {
            position: absolute; inset: 0; pointer-events: none; z-index: 20;
            padding: var(--spacing-lg); display: flex; flex-direction: column; justify-content: space-between;
            background: rgba(10, 10, 10, 0.3); backdrop-filter: blur(10px);
        }
        
        /* Biological rhythm pulse animation for live indicators */
        @keyframes pulse-bio {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .live-indicator {
            animation: pulse-bio 3s ease-in-out infinite;
        }
        .hud-row { display: flex; justify-content: space-between; align-items: flex-end; }
        .big-val { font-family: 'JetBrains Mono'; font-size: 48px; font-weight: 300; line-height: 1; }

        .dash-grid { display: grid; grid-template-columns: 1.5fr 1fr; gap: var(--spacing-xl); margin-top: var(--spacing-xl); }
        .insight-panel { 
            background: var(--bg-panel); border-left: 4px solid var(--success); 
            padding: var(--spacing-md); border-radius: 0 var(--radius) var(--radius) 0;
        }
        .stat-row { display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid var(--border); }
        .chart-box { height: 120px; display: flex; align-items: flex-end; gap: 8px; padding-top: 20px; }
        .chart-bar { flex: 1; background: var(--accent); opacity: 0.3; transition: height 0.5s; border-radius: 2px 2px 0 0; }
        .chart-bar.current { opacity: 1; }

    </style>
    
    <!-- Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- EMAIL JS -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
</head>
<body>

    <video id="input_video" playsinline></video>
    <div id="canvas-layer"></div>

    <button class="theme-toggle" onclick="Theme.toggle()"><i class="fas fa-adjust"></i></button>

    <!-- 1. LANDING -->
    <section id="v-landing" class="view active" style="z-index: 30;">
        <div class="container center-col">
            <div class="t-mono t-accent" style="margin-bottom: 24px;">CLINICAL RESONANCE PLATFORM v3.4.5</div>
            <h1 class="t-hero">ZENITH</h1>
            <p class="t-body" style="max-width: 500px; margin: 24px auto;">
                A prescriptive digital therapeutic tool. We use computer vision to translate your biological rhythms into visual structure, helping you regulate anxiety, tremors, and focus drift.
            </p>
            <button class="btn" onclick="UI.showModal('modal-intake')">BEGIN THERAPY</button>
        </div>
    </section>

    <!-- MODAL: INTAKE -->
    <div id="modal-intake" class="view" style="background: rgba(10, 10, 10, 0.8); backdrop-filter: blur(20px); z-index: 100;">
        <div class="container center-col" style="justify-content: center; max-width: 450px;">
            <div class="t-mono t-muted" style="text-align: left; width: 100%; margin-bottom: 30px;">PATIENT CHECK-IN</div>
            <input type="text" id="in-name" placeholder="First Name">
            <input type="email" id="in-email" placeholder="Email for Results">
            <p class="t-mono t-muted" style="text-align: left; line-height: 1.5; margin-top: 20px;">
                <i class="fas fa-lock"></i> PRIVACY NOTICE: Your camera data is processed locally in RAM. Only the final text report is emailed.
            </p>
            <div style="width: 100%; text-align: right; margin-top: 30px;">
                <button class="btn" onclick="App.submitIntake()">CONFIRM</button>
            </div>
        </div>
    </div>

    <!-- 2. PROTOCOL SELECTION -->
    <section id="v-triage" class="view" style="z-index: 30;">
        <div class="container center-col">
            <div class="t-mono t-accent" style="margin-bottom: 40px;">SELECT TREATMENT PROTOCOL</div>
            <div class="grid-3">
                
                <div class="card" onclick="App.selectProtocol('A')">
                    <div><div class="t-mono t-accent">2:44 MINS</div><h3 class="t-h3" style="margin-top:12px;">ANXIETY</h3><p class="t-body" style="font-size:13px; margin-top:8px;">Vagal toning via respiratory synchronization.</p></div><div class="t-mono t-muted">PROTOCOL A</div>
                </div>
                
                <div class="card" onclick="App.selectProtocol('B')">
                    <div><div class="t-mono t-accent">2:30 MINS</div><h3 class="t-h3" style="margin-top:12px;">STROKE / TREMOR</h3><p class="t-body" style="font-size:13px; margin-top:8px;">Neuro-motor calibration using movement grids.</p></div><div class="t-mono t-muted">PROTOCOL B</div>
                </div>
                
                <div class="card" onclick="App.selectProtocol('C')">
                    <div><div class="t-mono t-accent">2:59 MINS</div><h3 class="t-h3" style="margin-top:12px;">ADHD / FOCUS</h3><p class="t-body" style="font-size:13px; margin-top:8px;">Executive attention training via gaze locking.</p></div><div class="t-mono t-muted">PROTOCOL C</div>
                </div>
                
                <div class="card" onclick="App.selectProtocol('D')">
                    <div><div class="t-mono t-accent">2:15 MINS</div><h3 class="t-h3" style="margin-top:12px;">DYSPRAXIA</h3><p class="t-body" style="font-size:13px; margin-top:8px;">Micro-mobility and fine coordination warmup.</p></div><div class="t-mono t-muted">PROTOCOL D</div>
                </div>
                
                <div class="card" onclick="App.selectProtocol('E')">
                    <div><div class="t-mono t-accent">2:44 MINS</div><h3 class="t-h3" style="margin-top:12px;">SENSORY OVERLOAD</h3><p class="t-body" style="font-size:13px; margin-top:8px;">Low-stimulus flow for nervous system regulation.</p></div><div class="t-mono t-muted">PROTOCOL E</div>
                </div>
                
                <div class="card" onclick="App.selectProtocol('F')">
                    <div><div class="t-mono t-accent">2:20 MINS</div><h3 class="t-h3" style="margin-top:12px;">COGNITIVE BURNOUT</h3><p class="t-body" style="font-size:13px; margin-top:8px;">Visual resetting to clear mental fatigue.</p></div><div class="t-mono t-muted">PROTOCOL F</div>
                </div>

            </div>
        </div>
    </section>

    <!-- CALIBRATION MODAL (INSTRUCTIONAL) -->
    <div id="modal-calib" class="view" style="background: rgba(10, 10, 10, 0.8); backdrop-filter: blur(20px); z-index: 100; align-items:center; justify-content:center;">
        <div style="text-align:center; max-width: 600px; padding: 20px;">
            <div class="t-mono t-accent" id="calib-proto-name" style="margin-bottom:20px;">PROTOCOL A</div>
            <h1 class="t-hero" id="calib-countdown" style="font-size:80px;">5</h1>
            
            <div style="margin-top: 30px; border-top: 1px solid var(--border); padding-top: 30px;">
                <p class="t-mono t-muted">INSTRUCTION</p>
                <h2 class="t-h2" id="calib-instruction" style="margin-top: 10px;">Breathe with the pulse</h2>
            </div>
            
            <p class="t-mono t-muted" style="margin-top: 40px; color: var(--accent);">BASELINING SENSORS... HOLD STEADY</p>
        </div>
    </div>

    <!-- 3. ACTIVE HUD -->
    <div id="v-session" style="display:none;">
        <div id="hud-layer">
            <div class="hud-row" style="align-items: flex-start;">
                <div>
                    <div class="t-mono t-accent" id="hud-proto-id">PROTOCOL A</div>
                    <div class="t-h3" id="hud-proto-name">ANXIETY REGULATION</div>
                </div>
                <div style="text-align: right;">
                    <div class="big-val" id="hud-timer">00:00</div>
                    <div class="t-mono t-muted">TIME REMAINING</div>
                </div>
            </div>
            <div class="hud-row">
                <div>
                    <div class="t-mono live-indicator" style="margin-bottom: 8px;">LIVE FEEDBACK</div>
                    <div class="t-h3 t-accent" id="hud-instruction">SYNCHRONIZE BREATH</div>
                </div>
                <div style="text-align: right;">
                    <div class="big-val" id="hud-metric">--</div>
                    <div class="t-mono t-muted" id="hud-metric-label">VAGAL STABILITY</div>
                </div>
            </div>
        </div>
    </div>

    <!-- 4. RESULTS DASHBOARD -->
    <section id="v-debrief" class="view" style="z-index: 40; background: var(--bg-base);">
        <div class="container" style="padding-top: 60px;">
            <div class="t-mono t-accent" style="margin-bottom: 20px;">SESSION ANALYSIS COMPLETE</div>
            <h1 class="t-hero">YOUR RESULTS</h1>
            
            <div class="dash-grid">
                <div>
                    <div class="insight-panel" id="res-panel">
                        <div class="t-mono t-muted" style="margin-bottom: 12px;">CLINICAL OBSERVATION</div>
                        <p class="t-body" style="font-size: 18px; color: var(--text-pri); line-height: 1.6;" id="res-text">Calculating...</p>
                    </div>
                    <div style="margin-top: 30px;">
                        <div class="stat-row">
                            <span class="t-body">Start Baseline (Stress)</span>
                            <span class="t-mono" id="res-start">0.00</span>
                        </div>
                        <div class="stat-row">
                            <span class="t-body">End State (Stress)</span>
                            <span class="t-mono t-accent" id="res-end">0.00</span>
                        </div>
                        <div class="stat-row" style="border:none;">
                            <span class="t-body">Total Improvement</span>
                            <span class="t-mono t-accent" id="res-delta">+0%</span>
                        </div>
                    </div>
                    <div style="margin-top: 40px; border: 1px solid var(--border); padding: 16px; border-radius: var(--radius);">
                        <p class="t-mono t-muted">REPORT STATUS: <span id="mail-status" style="color:var(--text-pri); margin-left: 5px;">Queued</span></p>
                        <p class="t-mono t-muted" style="font-size: 10px; margin-top: 5px;">TO: <span id="res-email"></span></p>
                    </div>
                </div>
                <div style="display:flex; flex-direction:column; justify-content:space-between;">
                    <div class="card" style="height: 100%;">
                        <div class="t-mono t-muted">SESSION TREND</div>
                        <div class="chart-box" id="res-chart"></div>
                        <p class="t-mono" style="text-align: center; margin-top: 10px;">CONSISTENCY: <span class="t-accent">HIGH</span></p>
                    </div>
                </div>
            </div>
            <div style="margin-top: 60px; text-align: center;">
                <button class="btn-ghost" onclick="window.location.reload()">RETURN TO MENU</button>
            </div>
        </div>
    </section>

    <!-- LOGIC -->
    <script>
        'use strict';

        // ====================================================================
        // PHASE 1: CODEBASE ARCHITECTURE
        // ====================================================================
        // ZENITH operates on a four-pillar architecture:
        // 1. STATE MANAGEMENT: Centralized application state (user, protocol, session data)
        // 2. SENSOR PIPELINE: MediaPipe Hands → Vision module → stress calculation
        // 3. VISUAL ENGINE: Three.js/WebGL rendering with shader-based geometry
        // 4. INTELLIGENCE LAYER: Sentinel analysis → Results generation → Mailer reporting
        //
        // DATA FLOW:
        // Vision.stress → State.history (during session) → Sentinel.analyze() 
        // → Results.generate() → Mailer.send() → EmailJS API
        // ====================================================================

        // ====================================================================
        // 1. CONFIGURATION & PROTOCOL DEFINITIONS
        // ====================================================================
        const PROTOCOLS = {
            'A': { name: 'ANXIETY / CALM', time: 164, type: 'A', label: 'NERVOUS SYSTEM CALMNESS', advice: 'Breathe with the pulse' },
            'B': { name: 'STROKE / MOTOR', time: 150, type: 'B', label: 'MOVEMENT STEADINESS', advice: 'Sweep your hand slowly across the grid' },
            'C': { name: 'ADHD / FOCUS', time: 179, type: 'C', label: 'ATTENTION STAMINA', advice: 'Keep your gaze/hand in the center tunnel' },
            'D': { name: 'DYSPRAXIA / MOBILITY', time: 135, type: 'B', label: 'COORDINATION INDEX', advice: 'Trace the grid lines gently' },
            'E': { name: 'ASD / SENSORY', time: 164, type: 'A', label: 'SENSORY LOAD', advice: 'Focus on the flow, relax your shoulders' },
            'F': { name: 'BURNOUT / RESET', time: 140, type: 'C', label: 'COGNITIVE CLARITY', advice: 'Let your thoughts drift with the tunnel' }
        };

        // ====================================================================
        // 2. STATE MANAGEMENT LAYER
        // ====================================================================
        // Centralized state object tracking:
        // - User information (name, email)
        // - Active protocol selection
        // - Session status and calibration baseline
        // - Time-series history array for analysis
        // ====================================================================
        const State = {
            user: { name: '', email: '' },
            protocol: null, 
            active: false, 
            calibration: 0,
            history: []
        };

        // Initialize EmailJS (wrapped in IIFE to prevent global pollution)
        (function(){
            if (typeof emailjs !== 'undefined') {
                emailjs.init("KHTzvT8_pB_9tNoQE");
            } else {
                console.warn('EmailJS library not loaded');
            }
        })();

        // ====================================================================
        // 3. INTELLIGENCE LAYER: SENTINEL ENGINE
        // ====================================================================
        // Processes time-series data from State.history to generate clinical insights.
        // Calculates: Mean, Variance, StdDev, Start/End baselines, Volatility flags.
        // Returns: Observations array, Risk level, Start/End metrics.
        // ====================================================================
        const Sentinel = {
            analyze: (dataPoints, protocolType) => {
                // Input validation
                if (!dataPoints || !Array.isArray(dataPoints) || dataPoints.length === 0) {
                    console.warn('Sentinel: Invalid or empty data points');
                    return {
                        observations: ["Insufficient data for analysis."],
                        risk: "LOW",
                        start: 0,
                        end: 0
                    };
                }

                try {
                    const mean = dataPoints.reduce((a,b)=>a+b,0) / dataPoints.length;
                    const variance = dataPoints.reduce((a,b) => a + Math.pow(b-mean, 2), 0) / dataPoints.length;
                    const stdDev = Math.sqrt(variance);

                    const split = Math.floor(dataPoints.length / 2);
                    const first = dataPoints.slice(0, split).reduce((a,b)=>a+b,0) / split;
                    const second = dataPoints.slice(split).reduce((a,b)=>a+b,0) / split;
                    const improvement = first - second; 

                    let obs = [];
                    let risk = "LOW";

                    // Volatility check: Standard deviation threshold (0.25-0.3 on normalized scale)
                    if (stdDev > 0.25) {
                        obs.push("High volatility detected in movement patterns.");
                        risk = "MODERATE";
                    }
                    
                    // Fatigue check: Negative slope in final quadrant
                    if (improvement < -0.1) {
                        obs.push("Signs of rapid neuromuscular fatigue detected.");
                        risk = "MODERATE";
                    }
                    
                    if(obs.length === 0) {
                        obs.push("No motor or cognitive anomalies detected.");
                    }

                    return { observations: obs, risk: risk, start: first, end: second };
                } catch (error) {
                    console.error('Sentinel analysis error:', error);
                    return {
                        observations: ["Analysis error occurred."],
                        risk: "LOW",
                        start: 0,
                        end: 0
                    };
                }
            }
        };

        // ====================================================================
        // 4. INTELLIGENCE LAYER: MAILER MODULE
        // ====================================================================
        // Transmits session results via EmailJS API.
        // Only non-PII textual report is sent (no video/raw biometric data).
        // ====================================================================
        const Mailer = {
            send: (res) => {
                const stat = document.getElementById('mail-status');
                if (!stat) {
                    console.warn('Mail status element not found');
                    return;
                }
                
                stat.innerText = "Sending...";
                stat.style.color = "var(--accent)";

                // Validate EmailJS availability
                if (typeof emailjs === 'undefined') {
                    console.error('EmailJS library not available');
                    stat.innerText = "Email Service Unavailable";
                    stat.style.color = "var(--alert)";
                    return;
                }

                const params = {
                    to_name: State.user.name || 'Patient',
                    to_email: State.user.email || '',
                    protocol: PROTOCOLS[State.protocol]?.name || 'Unknown',
                    score: (res.score>0?'+':'')+res.score+'%',
                    start_val: res.start.toFixed(2),
                    end_val: res.end.toFixed(2),
                    risk_label: res.risk || 'LOW',
                    insight: (res.observations && Array.isArray(res.observations)) ? res.observations.join(" ") : 'No observations',
                    date: new Date().toLocaleDateString()
                };

                // Validate email format
                if (!params.to_email || !params.to_email.includes('@')) {
                    console.warn('Invalid email address');
                    stat.innerText = "Invalid Email Address";
                    stat.style.color = "var(--alert)";
                    return;
                }

                emailjs.send("service_wpwe6kc", "template_xxxx", params)
                    .then(() => {
                        stat.innerText = "Sent Successfully";
                        stat.style.color = "var(--success)";
                    })
                    .catch((err) => {
                        console.error('EmailJS send error:', err);
                        stat.innerText = "Connection Error (Check Console)";
                        stat.style.color = "var(--alert)";
                        // Log error details for debugging
                        if (err.text) {
                            console.error('EmailJS error details:', err.text);
                        }
                    });
            }
        };

        // ====================================================================
        // 5. UTILITY MODULES
        // ====================================================================
        // Data: LocalStorage persistence for session history (non-PII metrics only)
        // Voice: Text-to-speech for accessibility and user guidance
        // ====================================================================
        const Data = {
            saveSession: (result, risk) => {
                let history = JSON.parse(localStorage.getItem('zenith_history') || "[]");
                history.push({ date: new Date().toISOString(), score: result, risk: risk });
                localStorage.setItem('zenith_history', JSON.stringify(history));
            },
            getHistory: () => JSON.parse(localStorage.getItem('zenith_history') || "[]")
        };

        const Voice = {
            say: (msg) => {
                if(window.speechSynthesis) {
                    const u = new SpeechSynthesisUtterance(msg);
                    u.rate = 1.0; u.pitch = 1.0;
                    window.speechSynthesis.speak(u);
                }
            }
        };

        // ====================================================================
        // 6. APPLICATION CONTROLLER
        // ====================================================================
        // Orchestrates user flow: Intake → Protocol Selection → Calibration 
        // → Session → Results. Manages session timing and state transitions.
        // ====================================================================
        const App = {
            _initialized: false, // Guard against multiple initializations
            
            init: () => {
                if (App._initialized) return;
                App._initialized = true;
                Theme.apply();
            },

            submitIntake: () => {
                try {
                    const n = document.getElementById('in-name')?.value.trim();
                    const e = document.getElementById('in-email')?.value.trim();
                    if(!n || !e) {
                        alert("Please complete check-in.");
                        return;
                    }
                    
                    // Basic email validation
                    if (!e.includes('@') || !e.includes('.')) {
                        alert("Please enter a valid email address.");
                        return;
                    }
                    
                    State.user = { name: n, email: e };
                    Voice.say(`Welcome, ${n}. Protocol selection active.`);
                    UI.switch('v-triage');
                    // Initialize Vision module (which will initialize Visuals)
                    Vision.init(); 
                } catch (error) {
                    console.error('Intake submission error:', error);
                    alert("An error occurred. Please try again.");
                }
            },

            selectProtocol: (pid) => {
                try {
                    if (!PROTOCOLS[pid]) {
                        console.error(`Invalid protocol ID: ${pid}`);
                        return;
                    }
                    
                    State.protocol = pid;
                    const conf = PROTOCOLS[pid];
                    
                    const protoNameEl = document.getElementById('calib-proto-name');
                    const instructionEl = document.getElementById('calib-instruction');
                    const countdownEl = document.getElementById('calib-countdown');
                    
                    if (!protoNameEl || !instructionEl || !countdownEl) {
                        console.error('Calibration modal elements not found');
                        return;
                    }
                    
                    protoNameEl.innerText = `PROTOCOL ${pid}: ${conf.name}`;
                    instructionEl.innerText = conf.advice;
                    
                    UI.showModal('modal-calib');
                    Voice.say(`Protocol ${pid} selected. ${conf.advice}. Calibrating.`);
                    
                    let count = 5;
                    let calReadings = [];
                    const int = setInterval(() => {
                        count--;
                        countdownEl.innerText = count;
                        calReadings.push(Vision.stress || 0);
                        if(count <= 0) {
                            clearInterval(int);
                            const baseline = calReadings.length > 0 
                                ? calReadings.reduce((a,b)=>a+b,0)/calReadings.length 
                                : 0.5;
                            State.calibration = baseline;
                            UI.hideModal('modal-calib');
                            App.runSession(pid);
                        }
                    }, 1000);
                } catch (error) {
                    console.error('Protocol selection error:', error);
                }
            },

            runSession: (pid) => {
                try {
                    const conf = PROTOCOLS[pid];
                    if (!conf) {
                        console.error(`Protocol configuration not found: ${pid}`);
                        return;
                    }
                    
                    const protoIdEl = document.getElementById('hud-proto-id');
                    const protoNameEl = document.getElementById('hud-proto-name');
                    const metricLabelEl = document.getElementById('hud-metric-label');
                    const instructionEl = document.getElementById('hud-instruction');
                    const timerEl = document.getElementById('hud-timer');
                    const metricEl = document.getElementById('hud-metric');
                    
                    if (!protoIdEl || !protoNameEl || !metricLabelEl || !instructionEl || !timerEl || !metricEl) {
                        console.error('HUD elements not found');
                        return;
                    }
                    
                    protoIdEl.innerText = `PROTOCOL ${pid}`;
                    protoNameEl.innerText = conf.name;
                    metricLabelEl.innerText = conf.label;
                    instructionEl.innerText = conf.advice;
                    
                    Visuals.setType(conf.type);
                    State.active = true;
                    Voice.say("Session started. Begin.");
                    
                    let duration = conf.time;
                    State.history = []; 
                    UI.switch('v-session', true);
                    
                    const sessInt = setInterval(() => {
                        try {
                            duration--;
                            const m = Math.floor(duration/60);
                            const s = (duration%60).toString().padStart(2,'0');
                            timerEl.innerText = `0${m}:${s}`;
                            
                // Metric calculation: Normalized stress relative to calibration baseline
                // Formula: metric = 1 - (current_stress / (baseline * 2))
                // Higher metric = lower stress = better performance
                let metric = Math.max(0, 1 - (Vision.stress / (State.calibration * 2 || 1))); 
                State.history.push(metric);
                metricEl.innerText = Math.floor(metric * 100) + '%';

                            if(duration <= 0) {
                                clearInterval(sessInt);
                                App.endSession();
                            }
                        } catch (error) {
                            console.error('Session timer error:', error);
                            clearInterval(sessInt);
                        }
                    }, 1000);
                } catch (error) {
                    console.error('Session start error:', error);
                }
            },

            endSession: () => {
                State.active = false;
                Voice.say("Session complete. Processing report.");
                document.getElementById('canvas-layer').style.opacity = 0;
                Results.generate();
                UI.switch('v-debrief');
            }
        };

        // ====================================================================
        // 7. RESULTS GENERATION MODULE
        // ====================================================================
        // Processes Sentinel analysis output into human-readable report.
        // Updates UI with metrics, generates chart visualization, triggers email.
        // ====================================================================
        const Results = {
            generate: () => {
                const data = State.history;
                if (!data || data.length === 0) {
                    console.warn('No session data available for analysis');
                    return;
                }
                const analysis = Sentinel.analyze(data, State.protocol);
                
                // Score Calculation: Delta percentage from start to end baseline
                const delta = ((analysis.end - analysis.start) / analysis.start) * 100;
                const score = Math.floor(isFinite(delta) ? delta : 0);
                
                let text = `Primary Observation: Your ${PROTOCOLS[State.protocol].label.toLowerCase()} improved by ${score}%. \n\nCLINICAL NOTES:\n`;
                analysis.observations.forEach(o => text += `• ${o}\n`);

                const panel = document.querySelector('.insight-panel');
                if(analysis.risk === 'MODERATE') {
                    panel.style.borderLeftColor = 'var(--alert)';
                    text += "\nRECOMMENDATION: Share results with provider.";
                } else {
                    panel.style.borderLeftColor = 'var(--success)';
                }

                document.getElementById('res-text').innerText = text;
                document.getElementById('res-start').innerText = analysis.start.toFixed(2);
                document.getElementById('res-end').innerText = analysis.end.toFixed(2);
                document.getElementById('res-delta').innerText = (score>0?'+':'') + score + '%';
                document.getElementById('res-email').innerText = State.user.email;
                
                Data.saveSession(score, analysis.risk);
                Mailer.send({ score, text, start: analysis.start, end: analysis.end, risk: analysis.risk });

                const chart = document.getElementById('res-chart');
                chart.innerHTML = '';
                const step = Math.floor(data.length / 10) || 1;
                for(let i=0; i<10; i++) {
                    const val = data[i*step] || 0.5;
                    const h = Math.min(100, Math.max(10, val * 100));
                    const div = document.createElement('div');
                    div.className = 'chart-bar';
                    div.style.height = h + '%';
                    chart.appendChild(div);
                    setTimeout(()=> div.classList.add('current'), i*100);
                }
            }
        };

        // ====================================================================
        // 8. VISUAL ENGINE LAYER (WebGL/Three.js)
        // ====================================================================
        // Renders procedural 3D geometries based on stress biomarkers.
        // Modes: A (Sphere/Resonance), B (Grid/Orthopedic), C (Tunnel/Attention)
        // Signal Mapping: Vision.stress → uStress uniform → vertex displacement
        // ====================================================================
        const Visuals = {
            scene: null, 
            camera: null, 
            renderer: null, 
            points: null, 
            mode: 'A',
            _initialized: false, // Guard against multiple initializations
            
            init: () => {
                if (Visuals._initialized) return;
                Visuals._initialized = true;
                
                try {
                    Visuals.scene = new THREE.Scene();
                    Visuals.scene.fog = new THREE.FogExp2(0x050505, 0.002);
                    Visuals.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                    Visuals.camera.position.z = 50;
                    
                    Visuals.renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
                    Visuals.renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    // Cap devicePixelRatio at 2.0 for performance optimization
                    const dpr = Math.min(window.devicePixelRatio || 1, 2.0);
                    Visuals.renderer.setPixelRatio(dpr);
                    
                    const canvasEl = Visuals.renderer.domElement;
                    const canvasContainer = document.getElementById('canvas-layer');
                    if (canvasContainer) {
                        canvasContainer.appendChild(canvasEl);
                    } else {
                        console.error('Canvas container not found');
                        return;
                    }
                    
                    // Create point cloud geometry (5000 particles)
                    const geo = new THREE.BufferGeometry();
                    const pos = new Float32Array(5000 * 3);
                    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                    
                    // Custom shader for smooth point rendering with gl_PointCoord distance fading
                    const vertexShader = `
                        attribute vec3 position;
                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        uniform float size;
                        void main() {
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `;
                    
                    const fragmentShader = `
                        uniform vec3 color;
                        uniform float opacity;
                        void main() {
                            // Smooth edge fading using gl_PointCoord distance from center
                            vec2 center = gl_PointCoord - vec2(0.5);
                            float dist = length(center);
                            float alpha = 1.0 - smoothstep(0.0, 0.5, dist * 2.0);
                            gl_FragColor = vec4(color, opacity * alpha);
                        }
                    `;
                    
                    // Use custom shader material for enhanced antialiasing
                    const mat = new THREE.ShaderMaterial({
                        uniforms: {
                            color: { value: new THREE.Color(0xffffff) },
                            opacity: { value: 0.8 },
                            size: { value: 0.4 }
                        },
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
                        transparent: true,
                        depthWrite: false
                    });
                    
                    Visuals.points = new THREE.Points(geo, mat);
                    Visuals.scene.add(Visuals.points);
                    
                    // Handle window resize
                    window.addEventListener('resize', () => {
                        if (Visuals.camera && Visuals.renderer) {
                            Visuals.camera.aspect = window.innerWidth / window.innerHeight;
                            Visuals.camera.updateProjectionMatrix();
                            Visuals.renderer.setSize(window.innerWidth, window.innerHeight);
                        }
                    });
                    
                    Visuals.animate();
                } catch (error) {
                    console.error('Visuals initialization failed:', error);
                }
            },
            setType: (type) => {
                Visuals.mode = type;
                document.getElementById('canvas-layer').style.opacity = 1;
            },
            animate: () => {
                requestAnimationFrame(Visuals.animate);
                if(!State.active || !Visuals.points) return;
                
                const time = Date.now() * 0.001;
                const stress = Vision.stress || 0;
                const positions = Visuals.points.geometry.attributes.position.array;
                
                // Medical color grading: Interpolate between Medical Cyan (#00A3FF) and Clinical Red (#FF3B30)
                const isLight = document.documentElement.getAttribute('data-theme') === 'light';
                const medicalCyan = new THREE.Color(0x00A3FF);
                const clinicalRed = new THREE.Color(0xFF3B30);
                
                // Smooth color interpolation based on stress (smoothing factor 0.1 applied via stress value)
                const stressNormalized = Math.max(0, Math.min(1, stress));
                const currentColor = new THREE.Color();
                currentColor.lerpColors(medicalCyan, clinicalRed, stressNormalized);
                
                // Light mode: Invert brightness while maintaining contrast ratio (4.5:1 minimum)
                if (isLight) {
                    currentColor.multiplyScalar(0.15); // Darken for light mode
                }
                
                // Update shader uniform (for custom shader material)
                if (Visuals.points.material.uniforms) {
                    Visuals.points.material.uniforms.color.value.copy(currentColor);
                } else {
                    // Fallback for PointsMaterial
                    Visuals.points.material.color.copy(currentColor);
                } 

                for(let i=0; i<5000; i++) {
                    const i3 = i*3;
                    let x, y, z;
                    
                    if(Visuals.mode === 'A') { // SPHERE
                        const r = 25 + Math.sin(time * 0.6) * 5; 
                        const phi = Math.acos(-1 + (2*i)/5000);
                        const th = Math.sqrt(5000 * Math.PI) * phi;
                        x = r * Math.sin(phi) * Math.cos(th); y = r * Math.sin(phi) * Math.sin(th); z = r * Math.cos(phi);
                        if(stress > 0.5 && Math.random() > 0.9) { x+=1; y+=1; }
                    } else if (Visuals.mode === 'B') { // GRID
                        const w = 150; const dim = 70;
                        const r = Math.floor(i/dim); const c = i%dim;
                        x = (c/dim - 0.5) * w; z = (r/dim - 0.5) * w;
                        y = Math.sin(x*0.1 + time)*5 + Math.sin(z*0.1 + time)*5;
                        if(stress > 0.5) y = y * 0.2 + (Math.random()); 
                    } else { // TUNNEL
                        const ang = (i/5000) * Math.PI * 40; const rad = 10 + (i%5)*3;
                        x = Math.cos(ang)*rad; y = Math.sin(ang)*rad;
                        let speed = 2 + (stress*5); z = (i * 0.1 + time * 10 * speed) % 100; z -= 50;
                    }
                    positions[i3] = x; positions[i3+1] = y; positions[i3+2] = z;
                }
                Visuals.points.geometry.attributes.position.needsUpdate = true;
                Visuals.renderer.render(Visuals.scene, Visuals.camera);
            }
        };

        // ====================================================================
        // 9. SENSOR PIPELINE LAYER (MediaPipe Hands)
        // ====================================================================
        // Captures hand landmarks via webcam, calculates velocity/jitter/drift.
        // Derives stress biomarker: (velocity * weight_v) + (jitter * weight_j)
        // All processing occurs locally in RAM (zero-trust architecture).
        // ====================================================================
        const Vision = {
            stress: 0, 
            lastPos: {x: 0, y: 0},
            _initialized: false, // Guard against multiple camera starts
            _camera: null,
            _hands: null,
            
            init: () => {
                if (Vision._initialized) {
                    console.warn('Vision module already initialized');
                    return;
                }
                
                try {
                    const vid = document.getElementById('input_video');
                    if (!vid) {
                        console.error('Video element not found');
                        return;
                    }
                    
                    // Check if MediaPipe Hands is available
                    if (typeof Hands === 'undefined') {
                        console.error('MediaPipe Hands library not loaded');
                        return;
                    }
                    
                    Vision._hands = new Hands({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                    });
                    
                    Vision._hands.setOptions({
                        maxNumHands: 1, 
                        modelComplexity: 0, 
                        minDetectionConfidence: 0.5
                    });
                    
                    Vision._hands.onResults((res) => {
                        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                            const lm = res.multiHandLandmarks[0];
                            const w = lm[0]; // Wrist landmark (index 0)
                        const dist = Math.hypot(w.x - Vision.lastPos.x, w.y - Vision.lastPos.y);
                        
                        // Stress calculation with exponential smoothing (0.9 decay, 0.1 new data)
                        // Velocity component: dist * 20 scales normalized coordinates (0-1) to stress metric
                        // Higher velocity/jitter = higher stress = visual chaos
                        Vision.stress = (Vision.stress * 0.9) + (dist * 20 * 0.1);
                            Vision.lastPos = {x: w.x, y: w.y};
                        } else {
                            // Graceful decay when hand leaves frame (prevent visual jarring)
                            Vision.stress *= 0.95;
                        }
                    });
                    
                    // Initialize camera with error handling
                    if (typeof Camera === 'undefined') {
                        console.error('MediaPipe Camera library not loaded');
                        return;
                    }
                    
                    Vision._camera = new Camera(vid, {
                        onFrame: async () => {
                            try {
                                await Vision._hands.send({image: vid});
                            } catch (error) {
                                console.warn('MediaPipe frame processing error:', error);
                            }
                        },
                        width: 640, 
                        height: 480
                    });
                    
                    Vision._camera.start().catch((error) => {
                        console.error('Camera initialization failed:', error);
                        alert('Camera access denied. Please enable camera permissions to use ZENITH.');
                    });
                    
                    Vision._initialized = true;
                    
                    // Initialize Visuals after Vision is ready
                    Visuals.init();
                } catch (error) {
                    console.error('Vision initialization error:', error);
                }
            }
        };

        // ====================================================================
        // 10. THEME MANAGEMENT
        // ====================================================================
        // Handles light/dark mode switching. Updates CSS variables and WebGL uniforms.
        // ====================================================================
        const Theme = {
            current: 'dark',
            toggle: () => {
                Theme.current = Theme.current === 'dark' ? 'light' : 'dark';
                Theme.apply();
            },
            apply: () => {
                document.documentElement.setAttribute('data-theme', Theme.current);
                // WebGL color update happens in Visuals.animate() loop
            }
        };

        // ====================================================================
        // 11. UI CONTROLLER
        // ====================================================================
        // Manages view transitions, modal display, and canvas layer visibility.
        // ====================================================================
        const UI = {
            switch: (id, sess) => {
                document.querySelectorAll('.view').forEach(v => {
                    v.classList.remove('active');
                    if(id !== 'v-session' && v.id !== id) v.style.display = 'none';
                });
                const t = document.getElementById(id);
                if (!t) {
                    console.warn(`View element not found: ${id}`);
                    return;
                }
                t.style.display = 'block';
                setTimeout(() => t.classList.add('active'), 50);
                if(id === 'v-session') {
                    document.getElementById('v-session').style.display = 'block';
                    document.getElementById('canvas-layer').style.opacity = 1;
                } else {
                    document.getElementById('v-session').style.display = 'none';
                    document.getElementById('canvas-layer').style.opacity = 0;
                }
            },
            showModal: (id) => {
                const el = document.getElementById(id);
                el.style.display = 'flex';
                setTimeout(()=>el.classList.add('active'), 10);
            },
            hideModal: (id) => {
                const el = document.getElementById(id);
                el.classList.remove('active');
                setTimeout(()=>el.style.display = 'none', 500);
            }
        };

        // ====================================================================
        // INITIALIZATION
        // ====================================================================
        // Module initialization order:
        // 1. App.init() → Theme.apply() (sets initial theme)
        // 2. Vision.init() → Visuals.init() (triggered on intake submission)
        // 3. User flow: Intake → Protocol → Calibration → Session → Results
        // ====================================================================
        App.init();

    </script>
</body>
</html>
